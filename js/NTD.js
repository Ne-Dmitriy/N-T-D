// Ниже команды, с помощью которых мы находим элементы на странице [document - значит, что обращаемся ко всему документу] 

// 1) Записываем "#form" в константу form 

const form = document.querySelector("#form");  

// 2) Записываем "#taskInput" в константу taskInput 

const taskInput = document.querySelector("#taskInput"); 

// 3) Находим на странице тег <ul> - список задач - по id "tasksList"; 

const tasksList = document.querySelector("#tasksList"); 

// 4) Находим на странице элемент (Список задач пуст)

const emptyList = document.querySelector("emptyList"); 


// Создаём массив со всеми задачами.
// Создаём переменную tasks, равную на старте пустому массиву.
// При добавлении задач, каждая новая далее будет добавляться в этот массив. При удалени задачи - она будет удаляться. Статус задачи также будет меняться внутри массива.   
// Массив будет сохраняться в LS, и все данны будут храниться в браузере. 
// Переходим в функцию function addTask(event) (54-ая строка).

let tasks = []; 


// Отслеживание события отправки формы (form) 

// 1) Обращаемся к константе form; вызываем у неё метод addEventListener, который принимает в себя два аргумента - события, которые мы хотим отследить. 
// Первый - событие "submit" - срабатывает при отправке формы (form). Второй - функция, которая будет выполнена, когда произойдёт нужное нам событие. 

// 2) Параметр event/e с методом preventDefault. Отменяет обновление страницы при отправке формы. 

form.addEventListener("submit", addTask);        


// Удаление задач из списка задач по нажатии на кнопку. Отслеживаем клик, когда клик произошёл - удаляем задачу из списка. 
// Обращаемся к tasksList, вызываем addEventListener с первым аргументом "click", и вторым - функцией, которая будет удалять задачу (deleteTask). 
// Описание функции на 155-ой строке. 

tasksList.addEventListener("click", deleteTask); 
	

// Большую call-back функцию выше (form.addEventListener("submit", function (event) {), опишем как отдельную функцию и передадим её.
// Объявляем новую функцию addTask(event) (называем функции глаголом, чтобы понимать, что она делает). Переносим в неё весь код верхней функции, не затрагивая её открытия и закрытия.
// Вырезаем содеражание функции из его изначального положения.
// Передаём функцию function addTask(event) как второй аргумент. Передаём только название функции, чтобы не запускать её сразу, а после submit.
// Теперь функцию можно скрыть для удобства. 
// Эта функция описана способом function decloration (function названиефункции(){телофункции}) - это значит, что её можно вызвать до того, как они объявлены в коде. 
// (описана на 54-ой строке, а вызывается на 42-ой). Все остальные функции могут раотать только после того, как были объявлены (ниже по коду).  

function addTask(event) { 
		event.preventDefault();
	
	
	// Достаём текст задачи из поля ввода. Элемент taskInput с свойством value, которое содержит значение, введённое в taskInput.
	// Создаём константу taskText (текст задачи). В этой константе будет хранится значение value, введённое в taskInput.
	// Проверяем в консоли через console.log(taskText); 
	
	const taskText = taskInput.value;
	
	// Формируем объект, который будет описывать задачу.
	// Константа newTask равна объекту с некоторыми свойствами.
	// Date - класс, now - метод. Текущее время будет формироваться в милисекундах. То есть - при создании новой задачи - id каждый раз будет новым. 
	// text = taskText (получаем из Inputa). 
	// Статус done на старте равен false, так как изначально задача невыполнена.
	
	const newTask = {
		id: Date.now(),
		text: taskText,
		done: false  
	} 
	
	// Добвавляем объект в массив с задачами.
	// Обращаемся к массиву tasks, вызываем у него метод push (добавляет элемент в конец массива).
	// Добавляем задачу newTask, описанную в виде объекта. 
	// Можно выполнить проверку: console.log(tasks); 
	
	tasks.push(newTask); 
	
	// Формируем css-класс. Используем тернарый оператор = условие ? код,_который_выполнится_если_условие_верно : код,_который_выполнится_если_условие_неверно; 
	// newTask.done - проверяем, что хдесь записано. 
	
	const cssClass = newTask.done ? "task-title task-title--done" : "task-title"; 
	
	
	// Формирование разметки для новой задачи. Генерируем разметку для каждой задачи, которую будем добавлять. 
	// Создаём константу taskHTML (HTML-разметка для задачи). Используем шаблонные строки - обратные кавычки. Вставляем внутрь ту разметку, которую нужно генерировать.
	// Через ${} - используем интерполяцию - вставляем на место значения переменную.
	// Меняем taskText на newTask.text, чтобы получить значение taskText, которое записано в свойстве text объекта newTask.
	// Добавляем id тегу <li> через интерполяцию ${}. 
	// Добавляем <span> класс "${cssClass}".  
	
	const taskHTML = `
				<li id="${newTask.id}" class="list-group-item d-flex justify-content-between task-item">
					<span class="${cssClass}">${newTask.text}</span> 
					<div class="task-item__buttons"> 
						<button type="button" data-action="done" class="btn-action">
							<img src="./img/tick.svg" alt="Done" width="18" height="18">
						</button>
						<button type="button" data-action="delete" class="btn-action">
							<img src="./img/cross.svg" alt="Done" width="18" height="18">
						</button>
					</div>
				</li>`; 
				
				
	// Добавление задачи на старницу. Обращаемся к списку задач <ul>; Добавляем кусок разметки <li> в тег <ul>, который будет содержать все задачи. 
	// Вызываем у тега tasksList метод insertAdjacentHTML. Метод принимает в себя два аргумента. 
	// Первый - куда будет добавлен кусок кода - перед элементом, в его начало, конец, или после элемента. Новые задачи будут добавляться в конец списка - поэтому выбираем beforeend.
	// Второй - передаём сюда кусок разметки, который хотим отобразить (записан в константе taskHTML).  
	
	tasksList.insertAdjacentHTML("beforeend", taskHTML);  
	
	// Очищаем поле ввода taskInput после ввода нового значения, и возвращаем на него фокус.
	// Обращаемся к taskInput и его свойтсву value.
	// Дефолтное значение поля ввода будет равно пустой строке ("" - пустые кавычки)/ 
	// Возвращаем фокус на поля ввода после введения значения с помощью метода focus().
	
	taskInput.value = "";
	taskInput.focus();  
	
	// пропадание элемента (Список задач пуст id="emptyList") при очистке списка. 
	// Первым делом - проверяем, ессть ли задачи в списке (tasksList).
	// (tasksList.children)  возвращает нам коллекцию html-элементов, которые находятся внутри него  (внутри tasksList).
	// у коллекции есть свойство lenght (tasksList.children.lenght) - возвращает количесвто элементов в коллекции - количесвто тегов, лежащих в теге <ul> (tasksList). 
	// Если количесвто элементов больше, чем один (>1), мы понимаем, что задачи есть. Если есть один элемент - emptyList - мы понимаем, что список пуст. 
	// Закомментируем тестовую задачу "вынести мусор" в html-файле <!-- здесь <li></li> -->. Теперь внутри тега <ul> один элемент. 
 	// Проверяем, что если количесвто элементов внутри <ul> больше, чем 1 (есть emptyList и ещё какая-то добавленная задача), то  мы обращаемся к emptyList и скрываем его. 
	// Скрываем emptyList - добавляем класс (с помощью classList.add). 
	// Класс "none" прописан в css (none {display: none !important;}). У элемента работает свойство display: none - и он скрывается и не показываетсяя на странице.   
	
	if (tasksList.children.lenght > 1) {
		emptyList.classList.add("none") 
	}; 
	
	// saveHTMLtoLS();  
} 


// Можно проверить в консоли с помощью console.log(event.target);
// В css-файле  прописано свойство .btn-action; pointer-events: none; - для картинки, которая лежит внутри кнопки (87-ая строка css).
// Этим мы снимаем все события с элемента, клик проходит как бы сквозь него. Это нужно для того, чтобы функция срабатывала при нажатии на кнопку, поверх которой расположена картинка. 
// У кнопок есть прописанные атрибуты: у кнопки удаления - data-action="delete", у кнопки выполнения задачи - data-action="done".
// В данный момент нам нужна кнопка с атрибутом data-action="delete". 
// Обращаемся к атрибуту dataset - затем выбираем название data-атрибута; и проверяем, если его значение равно "delete" (если при клике на кнопку в ней есть "delete" - это нужная.
// Чтобы удалить нужную кнопку, найдём тег <li>, в который она вложена, и удалим этот тег <li>. 
// Находим среди родителей кнопки тег <li> с помощью обращения к кнопке event.target. с вызыванием её метода closest, который производит поиск среди родителей этой кнопки.
// Выполянем поиск либо просто по тегу <li>, либо по селекторам (например, по классу ".list-group-item"); 
// После того, как был найден нужный элемент, запишем его в константу parentNode.
// После, удаляем родительскую ноду, вызывая у неё метод remove().  

function deleteTask(event) {
	if (event.target.dataset.action !== "delete") return;  
		
		const parentNode = event.target.closest(".list-group-item");
		
		// Удаляем задачу из данных.
		// Определяем id задачи: console.log(parenNode.id);  
		// Определяем id в отдельную константу.  
		
		const id = Number(parentNode.id); 
		
		// Находим индекс задачи в массиве. Вызываем у массива tasks метод findIndex.
		// Метод findIndex принимает в себя функцию, которую запускает по очереди для каждого элемента массива. 
		// Если функция возвращает true, то этот элемент массива подходит под условия findIndex и метод findIndex вернёт индекс этого элемента.
		// Используем либо нестрогое сравнение (==), либо const id = Number(parentNode.id); вместо просто const id = parentNode.id;. 
		// Результат записываем в константу index.
		// Этот вариант выглядит как const index = tasks.findIndex(function (task) {
		//	if (task.id === id) {
		//		return true;  
		//	}  
		// Можно упростить его до return task.id === id;. 
		// Можно перевести в стелочную функцию, так как есть только return: const index = tasks.findIndex((task) => task.id === id); 
		
		const index = tasks.findIndex(function (task) {
			return task.id === id; 
		});  
		
		// Удаляем задачу из массива с задачами task. 
		// Вызываем у массива tasks метод splice с аргументами: индекс, с которого нужно начать вырезать элементы из массива(index) и колличество элементов, которые надо вырезать. 
		
		tasks.splice(index, 1);  
		
		// Можно реализовать ту же функцию через фильтрацию исходного массива, и недопускания попадания нужной задачи в новый массив.
		// Элементы, для которых функция вернёт true попадут в новый массив, а для которых false - не попадут.
		// tasks должен быть обозначен через переменную let, а не через константу const. 
		// tasks = tasks.filter(function (task) {
		//		if (task.id === id) {
		//		return false
		// 		} else {
		//			return true
		// 		}
		// })
		
		
		// Удаление задачи из разметки. 
		
		parentNode.remove();  
	
	// После удаления всех задач, нам необходимо снова отобразить блок "список пуст".
	// == - нестрогое сравнение; === - строгое сравнение по типам.
	// Если в списке задач один элемент - показываем блок "список пуст".
	// Список функций emptyList уже найден ранее. Обращаемся к его классам и удаляем у него класс "none".    
	
	if (tasksList.children.lenght === 1) {
		emptyList.classList.remove("none") 
	};
	
	// saveHTMLtoLS(); 
} 
 

// Отмечаем задачи как выполненные. Так же, как и выше, будем слушать клик по всему списку задач. В момент клика будем запускать функцию doneTask.
// Сперва, также обращаемся к tasksList, также запускаем прослушку событий addEventListener, также слушаем "click". 
// По клику запускаем функцию doneTask
// С помощью addEventListener можно привязывать несколько прослушек к одному и тому же событию и запускать разные функции. При клике срабатывают обе функции, но выбирается нужная. 
// Также задаём условие через if (event.target.dataset.action === ) 
// Чтобы отобразить задачу как зачёркнутую, находим нужный <span> и присваиваем ему класс, наличие которого будет зачёркивать задачу в спсике.
//  Искать нужный <span> буедм следующим образом: после клика на кнопку, мы поднимемся вверх до родительского элемента - <li>, а потом найдём внутри нужный <span>.
// Искать с помощью parentNode.querySelector() можно по тегу <span>, либо по селектору (например, class="task-title"). 
// После, записываемый найденный элемент parentNode.querySelector(".task-title"); в константу taskTitle. 
// Добавляем к <span> нужный класс: обращаемся к taskTittle, через classList, через метод add или toggle передаём название класса, который нужно добавить. 
// Название класса в toggle передаём уже без точки, так как работаем через classList (подразумевает, что передаётся название класса).
// add добавляет класс, а toggle добавляет и убирает.  

tasksList.addEventListener("click", doneTask)  

function doneTask(event) {
	if (event.target.dataset.action === "done") {
		const parentNode = event.target.closest(".list-group-item");
		
		// Отображаем выполнение задач в массиве.
		// Находим задчу по id в массиве задач, после меняем свойство done на противоположное (true на false, false на true).
		// Метод find работает похоже на findIndex, но возвращает сам найденный элемент, а не его индекс. 
		// Из разметки мы получаем id в виде строки (parentNode.id;), а в (task.id) записано число. Поэтому применем Number или == (нестрогое сравнение).
		// Результат работы метода find заисываем в константу task. 
		
		const id = Number(parentNode.id); 
		
		const task = tasks.find(function (task) {
			if (task.id === id) {
				return true  
			}   
		})  
		
		// Можно упростить в стрелочную функцию const.task = tasks.find( (task) => task.id === id) 
		
		// Константа task меняет объект в массиве, потому что ссылается на него же. 
		
		task.done = !task.done 
		
		
		const taskTitle = parentNode.querySelector(".task-title"); 
		taskTitle.classList.toggle("task-title--done");   
	} 
	
	// saveHTMLtoLS(); 
} 

// Сохраняем данные на локальном хранилище в браузере (localStorage (раздел Application консоли разработчика)).
// В Console вписываем комнаду localStorage и вызываем у неё метод setItem и передаём два аргумента:
// Первый - ключ по которому будут храниться данные (name), второй - данные (data). Названия даются самостоятельно. 
// localStorage.setItem("name", "data")  -  после чего данные заносятся в localStorage.
// Чтобы получить данные вписываем localStorage.getItem("name") в Console. 

// Функция, сохраняющая разметку в localStorage.
// saveHTMLtoLS - своё название функции; tasksHTML - ключ;
// HTML-разметка, которую нужно сохранить в LS находится в константе tasksList. Поэтому, вторым аргументом передаём её.
// Свойство innerHTML возвращает весь внутренний HTML, находящийся в прописанном элементе (в нашем случае константа tasksList). 

// function saveHTMLtoLS(){
// 		localStorage.setItem("tasksHTML", tasksList.innerHTML); 
// } 

// Вызывать данную функцию нам нужно при каждом изменении - и при добавлении, и при удалении, и при отметке задач как выполненных.
// Открываем функцию addTask(event) (54-ая строка), deleteTask(event) (155-ая строка) и doneTask(event) (190-ая строка).
// Вызываем в их низ saveHTMLtoLS(); 

// Следующий шаг - показ на странице HTML-данных, хранящихся в loacalStorage.
// Выше функций выполняем проверку: if (localStorage.getItem("tasksHTML")) {
// 	tasksList.innerHTML = localStorage.getItem("tasksHTML");  
// }
// Как это работает: если в LS есть данные по ключу "tasksHTML", innerHTML выдаёт их. 
// Метод описанный с 166-ой строки - антипатерн - рабочий, но нежелательный.


// Метод сохранения данных через работу с данными JS:
// Создаём массив, который будет содержать все задачи (строка 26).   


// СКрывать или отображать блок "Список задач пуст" можно через следующую функцию (для этого вначале удалить блок из разметки HTML и строки JS кода с условиеями блока).
// function checkEmptyList () {
//		if (tasks.length) === 0 )
//			const emptyListHTML = `<li id="emptyList" class="list-group-item empty-list">
//					<img src="./img/leaf.svg" alt="Empty" width="48" class="mt-3">
//					<div class="empty-list__title">Список задач пуст</div>
//				</li>`;
// 			tasksList.insertAdjacentHTML("afterbegin", emptyListHTML);  
// 
// 		} 
// 
// 		if (tasks.length) > 0) {
// 		const emptyListEl = document.querySelector("selector")
//  	emptyListEl ? emptyListEl.remove() : null; 
// 		}
// }


